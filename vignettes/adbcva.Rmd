---
title: "Creating ADBCVA"
output:
  rmarkdown::html_vignette:
vignette: >
  %\VignetteIndexEntry{Creating ADBCVA}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
link <- function(text, url) {
  return(
    paste0(
      "[", text, "]",
      "(", url, ")"
    )
  )
}
dyn_link <- function(text,
                     base_url,
                     relative_url = "",
                     # Change to TRUE when admiral adopts multiversion docs
                     is_multiversion = FALSE,
                     multiversion_default_ref = "main") {
  url <- paste(base_url, relative_url, sep = "/")
  if (is_multiversion) {
    url <- paste(
      base_url,
      Sys.getenv("BRANCH_NAME", multiversion_default_ref),
      relative_url,
      sep = "/"
    )
  }
  return(link(text, url))
}
# Other variables
admiral_homepage <- "https://pharmaverse.github.io/admiral"
library(admiraldev)
```

# Introduction

This article describes creating an ADBCVA ADaM with Best-Corrected Visual Acuity (BCVA) data for ophthalmology endpoints. It is to be used in conjunction with the article on [creating a BDS dataset from SDTM](https://pharmaverse.github.io/admiral/articles/bds_finding.html). As such, derivations/processes that are not specific to ADBCVA are absent, and the user is invited to consult the aforementioned article for guidance.

**Note**: *All examples assume CDISC SDTM and/or ADaM format as input unless
otherwise specified.*

## Required Packages

The examples of this vignette require the following packages.

```{r, warning=FALSE, message=FALSE}
library(dplyr)
library(admiral)
library(admiral.test)
library(admiraldev)
library(admiralophtha)
```

# Programming Workflow

* [Initial set up of ADBCVA ](#setup)
* [Deriving LogMAR score parameters](#logmar)
* [Further derivations of standard BDS variables](#further)
* [Deriving AVALCATs](#avalcats)
* [Deriving BCVA Criterion Flags](#critflags)
* [Additional Notes](#notes)
* [Example Script](#example)

## Initial set up of ADBCVA {#setup}

As with all BDS ADaM datasets, one should start from the OE SDTM, where only the BCVA records are of interest. For the purposes of the next two sections, we shall be using the `{admiral}` OE and ADSL test data. We will also require a lookup table for the mapping of PARAMCDs. Note: to simulate an ophthalmology study, we add a randomly generated STUDYEYE variable to ADSL, but in practice STUDYEYE will already have been derived using `derive_var_studyeye`.

```{r}
data("admiral_oe")
data("admiral_adsl")

# Add STUDYEYE to ADSL to simulate an ophtha dataset
adsl <- admiral_adsl %>%
  as.data.frame() %>%
  mutate(STUDYEYE = sample(c("LEFT", "RIGHT"), n(), replace = TRUE)) %>%
  convert_blanks_to_na()

oe <- convert_blanks_to_na(admiral_oe) %>%
  ungroup()

# ---- Lookup table ----
param_lookup <- tibble::tribble(
  ~OETESTCD, ~OELAT, ~STUDYEYE, ~PARAMCD, ~PARAM, ~PARAMN,
  "VACSCORE", "RIGHT", "RIGHT", "SBCVA", "Study Eye Visual Acuity Score", 1,
  "VACSCORE", "LEFT", "LEFT", "SBCVA", "Study Eye Visual Acuity Score", 1,
  "VACSCORE", "RIGHT", "LEFT", "FBCVA", "Fellow Eye Visual Acuity Score", 2,
  "VACSCORE", "LEFT", "RIGHT", "FBCVA", "Fellow Eye Visual Acuity Score", 2
)
```

Following this setup, the programmer can start constructing ADBCVA. The first step is to subset OE to only BCVA parameters and merge with ADSL. This is required for two reasons: firstly, STUDYEYE is crucial in the mapping of PARAMCDs. Secondly, the treatment start date (TRTSDT) is also a prerequisite for the derivation of Analysis Day (ADY). This last derivation can in fact be inserted into the workflow at this point.

```{r}
adsl_vars <- exprs(TRTSDT, TRTEDT, TRT01A, TRT01P, STUDYEYE)

adbcva <- oe %>%
  filter(
    OETESTCD %in% c("VACSCORE")
  ) %>%
  derive_vars_merged(
    dataset_add = adsl,
    new_vars = adsl_vars,
    by_vars = exprs(STUDYID, USUBJID)
  ) %>%
  derive_vars_dt(
    new_vars_prefix = "A",
    dtc = OEDTC,
    flag_imputation = "none"
  ) %>%
  derive_vars_dy(reference_date = TRTSDT, source_vars = exprs(ADT))
```

The next item of business is to derive AVAL, AVALU, and DTYPE. In this example, due to the small number of parameters their derivation is trivial.

```{r}
adbcva <- adbcva %>%
  mutate(
    AVAL = OESTRESN,
    AVALU = "letters",
    DTYPE = NA_character_
  )
```

Moving forwards, PARAM and PARAMCD can be assigned using `derive_vars_merged` from `{admiral}` and the lookup table `param_lookup` generated above.

```{r}
adbcva <- adbcva %>%
  derive_vars_merged(
    dataset_add = param_lookup,
    new_vars = exprs(PARAM, PARAMCD),
    by_vars = exprs(OETESTCD, OELAT, STUDYEYE),
    filter_add = PARAMCD %in% c("SBCVA", "FBCVA")
  )
```

## Deriving LogMAR score parameters {#logmar}

Often ADBCVA datasets contain derived records for BCVA in LogMAR units. This can easily be achieved as follows using `derive_param_computed`. The conversion of units is done using `convert_etdrs_to_logmar`. Note that two separate calls are required due to the parameters being split by study and fellow eye. Additionally, once these extra parameters are added, then AVALC can also be derived.

```{r}
adbcva <- adbcva %>%
  derive_param_computed(
    by_vars = exprs(USUBJID, VISIT),
    parameters = c("SBCVA"),
    analysis_value = convert_etdrs_to_logmar(AVAL.SBCVA),
    set_values_to = exprs(
      PARAMCD = "SBCVALOG",
      PARAM = "Study Eye Visual Acuity LogMAR Score",
      DTYPE = "DERIVED",
      AVALU = "LogMAR"
    )
  ) %>%
  derive_param_computed(
    by_vars = exprs(USUBJID, VISIT),
    parameters = c("FBCVA"),
    analysis_value = convert_etdrs_to_logmar(AVAL.FBCVA),
    set_values_to = exprs(
      PARAMCD = "FBCVALOG",
      PARAM = "Fellow Eye Visual Acuity LogMAR Score",
      DTYPE = "DERIVED",
      AVALU = "LogMAR"
    )
  ) %>%
  mutate(AVALC = as.character(AVAL))
```

## Further derivations of standard BDS variables {#further}

The user is invited to consult the article on [creating a BDS dataset from SDTM](https://pharmaverse.github.io/admiral/articles/bds_finding.html) to learn how to add standard BDS variables to ADBCVA. Henceforth, for the purposes of this article, the following sections use the ADBCVA dataset generated by the corresponding `{admiralophtha}` template program as a starting point.

**Note**: *This dataset already comes with some criterion flags and AVAL cat variables, so for illustration purposes these are removed.*

```{r}
data("admiral_adbcva")

adbcva <- adbcva %>% 
  select(-starts_with("CRIT"), -starts_with("AVALCA"))
```

## Deriving AVALCATs {#avalcats}

## Deriving BCVA Criterion Flags {#critflags}

`{admiralophtha}` suggests the use of criterion flag variable pairs (CRITx/CRITxFL) to program BCVA endpoints such as *Avoiding a loss of x letters*  or *Gain of y letters* or *Gain of between 5 and 10 letters* (relative to baseline or other basetypes). The package provides the function `derive_var_bcvacritxfl` to program these endpoints efficiently and consistently. In terms of the logic to apply to the variable `CHG`, the endpoints fall into three classes, which can be represented by inequalities:

* Class 1: `CHG` value lying inside a range, `a <= CHG <= b`.
* Class 2: `CHG` value below an upper limit, `CHG <= a`.
* Class 3: `CHG` value above a lower limit, `CHG => b`.

By using `derive_var_bcvacritxfl`, the ADaM programmer can implement all three types of endpoint at once. This is achieved by feeding the appropriate ranges, upper limits and lower limits to the `bcva_ranges`, `bcva_uplims` and `bcva_lowlims` arguments of the function. For instance, let's suppose that the endpoints of interest are:

* *Gain of between 5 and 10 letters relative to baseline* (Class 1: `5 <= CHG <= 10`)
* *Gain of 25 letters or fewer relative to baseline* (Class 2: `CHG <= 25`)
* *Loss of 5 letters or more relative to baseline* (Class 2: `CHG <= -5`)
* *Gain of 15 letters or more relative to baseline* (Class 3: `CHG >= 15`)
* *Loss of 10 letters or fewer relative to baseline* (Class 3: `CHG >= -10`).

Then, the following call will implement criterion variable/flag pairs for the endpoints above. The CRITx variables will automatically encode the correct inequality.

```{r}
adbcva <- adbcva %>% derive_var_bcvacritxfl(
   paramcds = c("SBCVA", "FBCVA"),
   bcva_ranges = list(c(5, 10)),
   bcva_uplims = list(25, -5),
   bcva_lowlims = list(15, -10)
 )
```

The resulting output is shown below (limited to the first patient only):

```{r, eval=TRUE, echo=FALSE}
dataset_vignette(
  adbcva %>% filter(USUBJID == "01-701-1015"),
  display_vars = exprs(
    USUBJID, PARAMCD, AVAL, CHG, CRIT1, CRIT1FL, CRIT2, CRIT2FL, CRIT3, CRIT3FL, CRIT4, CRIT4FL, CRIT5, CRIT5FL
    )
)
```

It is also possible to assign significance to the "x" in CRITxFL. For instance, one could designate all criterion flags of Class 1 as CRIT1yFL, Class 2 as CRIT2yFL, and Class 3 as CRIT3yFL. The argument `critxfl_index` allows a simple implementation of this in conjunction with three separate calls to `derive_var_bcvacritxfl`:

```{r}
adbcva <- adbcva %>% derive_var_bcvacritxfl(
   paramcds = c("SBCVA", "FBCVA"),
   bcva_ranges = list(c(5, 10)),
   critxfl_index = 10
 ) %>% 
  derive_var_bcvacritxfl(
   paramcds = c("SBCVA", "FBCVA"),
   bcva_uplims = list(25, -5),
   critxfl_index = 20
 ) %>% 
  derive_var_bcvacritxfl(
   paramcds = c("SBCVA", "FBCVA"),
   bcva_lowlims = list(15, -10),
   critxfl_index = 30
 ) 
```

## Additional Notes

* When interpreting endpoints such as *Loss of 5 letters or fewer relative to baseline*, it is implicitly assumed in this article that this also includes the case where letters are *gained*, so that the inequality reads `CHG >= -5`. One would then use the `bcva_lowlims = list(-5)` argument of `derive_var_bcvacritxfl`  to program such an endpoint. If this is not the case, i.e. one wishes to exclude cases of letter gains, then the inequality of interest would instead be `-5 <= CHG <= -1`. Importantly, `derive_var_bcvacritxfl` could still be used, but with the argument `bcva_ranges = list(c(-5, -1))`.

## Example Script {#example}

ADaM | Sample Code 
 ---- | -------------- 
ADBCVA | `r dyn_link("ad_advfq.R", "https://github.com/pharmaverse/admiralophtha/blob", "inst/templates/ad_adbcva.R", is_multiversion = TRUE)`

