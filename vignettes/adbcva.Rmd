---
title: "Creating ADBCVA"
output:
  rmarkdown::html_vignette:
vignette: >
  %\VignetteIndexEntry{Creating ADBCVA}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
link <- function(text, url) {
  return(
    paste0(
      "[", text, "]",
      "(", url, ")"
    )
  )
}
dyn_link <- function(text,
                     base_url,
                     relative_url = "",
                     # Change to TRUE when admiral adopts multiversion docs
                     is_multiversion = FALSE,
                     multiversion_default_ref = "main") {
  url <- paste(base_url, relative_url, sep = "/")
  if (is_multiversion) {
    url <- paste(
      base_url,
      Sys.getenv("BRANCH_NAME", multiversion_default_ref),
      relative_url,
      sep = "/"
    )
  }
  return(link(text, url))
}
# Other variables
admiral_homepage <- "https://pharmaverse.github.io/admiral"
library(admiraldev)
```

# Introduction

This article describes creating an ADBCVA ADaM with Best-Corrected Visual Acuity (BCVA) data for ophthalmology endpoints. It is to be used in conjunction with the article on [creating a BDS dataset from SDTM](https://pharmaverse.github.io/admiral/articles/bds_finding.html). As such, it that the user has already created a standard ADaM BDS dataset containing BCVA data.

**Note**: *All examples assume CDISC SDTM and/or ADaM format as input unless
otherwise specified.*

## Required Packages

The examples of this vignette require the following packages.

```{r, warning=FALSE, message=FALSE}
library(dplyr)
library(admiral)
library(admiral.test)
library(admiraldev)
library(admiralophtha)
```

# Programming Workflow

* [Obtaining the ADBCVA BDS dataset](#getadbcva)
* [Deriving AVALCATs](#avalcats)
* [Deriving BCVA Criterion Flags](#critflags)
* [Additional Notes](#notes)

## Obtaining the ADBCVA BDS dataset {#getadbcva}

For the purposes of this article, we shall be using the ADBCVA dataset generated by the corresponding `{admiralophtha}` template program. Note that this dataset already comes with some criterion flags, so for illustration purposes these are removed.

```{r}
data("admiral_adbcva")

adbcva <- adbcva %>% 
  select(-starts_with("CRIT"))
```

## Deriving AVALCATs {#avalcats}

## Deriving BCVA Criterion Flags {#critflags}

`{admiralophtha}` suggests the use of criterion flags to program BCVA endpoints such as *Avoiding a loss of x letters*  or *Gain of y letters* or *Gain of between 5 and 10 letters* (relative to baseline or other basetypes). The package provides the function `derive_var_bcvacritxfl` to program these endpoints efficiently and consistently. In terms of the logic to apply to the variable `CHG`, the endpoints fall into three classes, which can be represented by inequalities:

1. `CHG` value lying inside a range, `a <= CHG <= b`.
2. `CHG` value below an upper limit, `CHG <= a`.
3. `CHG` value above a lower limit, `CHG => b`.

By using `derive_var_bcvacritxfl`, the ADaM programmer can implement all three types of endpoint at once, by feeding the appropriate ranges, upper limits and lower limits to the `bcva_ranges`, `bcva_uplims` and `bcva_lowlims` arguments of the function. For instance, let's suppose that the endpoints of interest are:

* *Gain of between 5 and 10 letters relative to baseline* (Class 1: `5 <= CHG <= 10`)
* *Gain of 25 letters or fewer relative to baseline* (Class 2: `CHG <= 25`)
* *Loss of 5 letters or more relative to baseline* (Class 2: `CHG <= -5`)
* *Gain of 15 letters or more relative to baseline* (Class 3: `CHG >= 15`)
* *Loss of 10 letters or fewer relative to baseline* (Class 3: `CHG >= -10`).

These can be implemented using the following call:

```{r}
adbcva <- adbcva %>% derive_var_bcvacritxfl(
   paramcds = c("SBCVA", "FBCVA"),
   bcva_ranges = list(c(5, 10)),
   bcva_uplims = list(25, -5),
   bcva_lowlims = list(15, -10)
 )
```

The resulting output is shown below (limited to the first patient only):

```{r, eval=TRUE, echo=FALSE}
dataset_vignette(
  adbcva %>% filter(USUBJID == "01-701-1015"),
  display_vars = exprs(
    USUBJID, PARAMCD, AVAL, CHG, CRIT1, CRIT1FL, CRIT2, CRIT2FL, CRIT3, CRIT3FL, CRIT4, CRIT4FL, CRIT5, CRIT5FL
    )
)
```

It is also possible to assign significance to the "x" in CRITxFL. For instance, one could designate all criterion flags of Class 1 as CRIT1yFL, Class 2 as CRIT2yFL, and Class 3 as CRIT3yFL. The argument `critxfl_index` allows a simple implementation of this in conjunction with three separate calls to `derive_var_bcvacritxfl`:

```{r}
adbcva <- adbcva %>% derive_var_bcvacritxfl(
   paramcds = c("SBCVA", "FBCVA"),
   bcva_ranges = list(c(5, 10)),
   critxfl_index = 10
 ) %>% 
  derive_var_bcvacritxfl(
   paramcds = c("SBCVA", "FBCVA"),
   bcva_uplims = list(25, -5),
   critxfl_index = 20
 ) %>% 
  derive_var_bcvacritxfl(
   paramcds = c("SBCVA", "FBCVA"),
   bcva_lowlims = list(15, -10),
   critxfl_index = 30
 ) 
```

## Additional Notes

* When interpreting endpoints such as *Loss of 5 letters or fewer relative to baseline*, it is implicitly assumed in this article that this also includes the case where letters are *gained*, so that the inequality reads `CHG >= -5`. One would then use the `bcva_lowlims = list(-5)` argument of `derive_var_bcvacritxfl`  to program such an endpoint. If this is not the case, i.e. one wishes to exclude cases of letter gains, then the inequality of interest would instead be along the lines of `-5 <= CHG <= -1`. Importantly, `derive_var_bcvacritxfl` could still be used, but with the argument `bcva_ranges = list(c(-5, -1))`.

